import asyncio
import socket
import threading
import time
import json
import uuid
from collections import deque
import colorama
from colorama import Fore, Style
import aioconsole
import networkx as nx

# --- Initialize Libraries & Constants ---
colorama.init(autoreset=True)
PORT = 8888
BROADCAST_PORT = 9999

# --- Global State ---
peers = set()  # Direct connections (asyncio.StreamWriter objects)
available_peers = set()
peer_lock = threading.Lock()

def get_local_ip():
    """Gets the machine's local IP address."""
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
            s.connect(("8.8.8.8", 80))
            return s.getsockname()[0]
    except Exception: return "127.0.0.1"

LOCAL_IP = get_local_ip()

# --- Message & UI Formatting ---
def format_message(sender_ip, message, is_self=False, color=None, hops=0, is_private=False):
    """Formats messages with appropriate colors and metadata."""
    if color is None: color = Fore.CYAN
    if is_self: sender, color = "Me", Fore.GREEN
    elif sender_ip == "System": sender, color = "System", Fore.YELLOW
    else: sender = sender_ip
    
    hop_info = f" (via {hops} hop{'s' if hops != 1 else ''})" if hops > 0 else ""
    pm_info = "[Private] " if is_private else ""
    return f"{color}{pm_info}{sender}{hop_info}: {Style.RESET_ALL}{message}"

# --- The "Brain": Dijkstra's Routing Manager ---
class RoutingManager:
    def __init__(self, local_ip, peers_set):
        self.local_ip = local_ip
        self.peers = peers_set
        self.topology = nx.Graph()
        self.topology.add_node(local_ip)
        self.link_state_seq = 0
        self.last_lsa = {} # Stores the latest sequence number for each node's LSA

    def get_link_state_packet(self):
        """Creates a Link-State Advertisement (LSA) packet."""
        self.link_state_seq += 1
        neighbors = {
            writer.get_extra_info('peername')[0]: 1 # Cost of 1 for each direct link (hop count)
            for writer in self.peers if writer.get_extra_info('peername')
        }
        return {
            "type": "lsa", "source": self.local_ip,
            "seq": self.link_state_seq, "neighbors": neighbors
        }

    def update_topology(self, lsa):
        """Updates the network map with a received LSA."""
        source, seq = lsa["source"], lsa["seq"]
        if seq > self.last_lsa.get(source, -1):
            self.last_lsa[source] = seq
            edges_to_remove = list(self.topology.edges(source))
            self.topology.remove_edges_from(edges_to_remove)
            for neighbor, weight in lsa["neighbors"].items():
                self.topology.add_edge(source, neighbor, weight=weight)
            return True # LSA was new and applied
        return False # LSA was old or redundant

    def get_next_hop(self, destination_ip):
        """Runs Dijkstra's to find the best next hop."""
        try:
            path = nx.dijkstra_path(self.topology, self.local_ip, destination_ip)
            return path[1] if len(path) > 1 else None
        except (nx.NetworkXNoPath, nx.NodeNotFound):
            return None

    async def broadcast_lsa(self):
        """Periodically sends our link-state to all direct peers."""
        while True:
            await asyncio.sleep(10)
            lsa_packet = self.get_link_state_packet()
            lsa_json = json.dumps(lsa_packet) + "\n"
            for writer in list(self.peers):
                try:
                    writer.write(lsa_json.encode()); await writer.drain()
                except (ConnectionResetError, BrokenPipeError): self.peers.discard(writer)

# --- Connection Management ---
async def manage_connection(reader, writer, routing_manager):
    """Manages a connection: dispatches LSA and Chat packets."""
    peers.add(writer)
    peer_ip = writer.get_extra_info('peername')[0]

    try:
        while True:
            line = await reader.readline()
            if not line: break
            
            try:
                message_data = json.loads(line.decode())
                msg_type = message_data.get("type")

                if msg_type == "lsa":
                    if routing_manager.update_topology(message_data):
                        # Forward the new LSA to other peers to sync the map
                        for p_writer in list(peers):
                            if p_writer != writer:
                                p_writer.write(line); await p_writer.drain()
                
                elif msg_type == "chat":
                    dest = message_data.get("destination_ip")
                    if dest == routing_manager.local_ip or dest == "all":
                        await aioconsole.aprint(format_message(
                            message_data["origin_ip"], message_data["payload"],
                            hops=message_data["hops"], is_private=(dest != "all")))
                    
                    if dest != routing_manager.local_ip:
                        # Forward the message using the calculated best path
                        next_hop = routing_manager.get_next_hop(dest) if dest != "all" else None
                        message_data["hops"] += 1
                        forward_msg = json.dumps(message_data) + "\n"

                        if dest == "all": # Broadcast
                            for p_writer in list(peers):
                                if p_writer != writer: p_writer.write(forward_msg.encode()); await p_writer.drain()
                        elif next_hop: # Unicast
                            for p_writer in list(peers):
                                if p_writer.get_extra_info('peername')[0] == next_hop:
                                    p_writer.write(forward_msg.encode()); await p_writer.drain()
                                    break
            except (json.JSONDecodeError, KeyError): pass

    except (ConnectionResetError, asyncio.IncompleteReadError): pass
    finally:
        await aioconsole.aprint(format_message("System", f"🏃 Peer {peer_ip} disconnected."))
        if writer in peers: peers.remove(writer)
        routing_manager.topology.remove_node(peer_ip) # Remove node from map
        if not writer.is_closing(): writer.close(); await writer.wait_closed()

# --- Core Networking (simplified by passing manager) ---
async def connect_to_peer(ip, routing_manager):
    try:
        reader, writer = await asyncio.wait_for(asyncio.open_connection(ip, PORT), timeout=5)
        asyncio.create_task(manage_connection(reader, writer, routing_manager))
    except Exception as e:
        await aioconsole.aprint(format_message("System", f"❌ Failed to connect to {ip}: {e}", color=Fore.RED))

async def handle_peer(reader, writer, routing_manager):
    asyncio.create_task(manage_connection(reader, writer, routing_manager))

# --- UDP Discovery (Unchanged) ---
def udp_broadcast_task():
    # ... (code is unchanged)
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        while True:
            try: sock.sendto(LOCAL_IP.encode(), ("255.255.255.255", BROADCAST_PORT))
            except Exception: pass
            time.sleep(5)

def udp_listen_task():
    # ... (code is unchanged)
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1); sock.bind(('', BROADCAST_PORT))
        while True:
            ip = sock.recvfrom(1024)[0].decode()
            if ip != LOCAL_IP:
                with peer_lock: available_peers.add(ip)

# --- Main UI Loop (Updated for New Commands) ---
async def chat_interface(routing_manager):
    await aioconsole.aprint(format_message("System", "Welcome! Dijkstra routing is active. Type '/h' for help."))
    while True:
        user_input = await aioconsole.ainput("> ")
        if not user_input: continue

        if user_input.startswith('/'):
            parts = user_input.split()
            command = parts[0].lower()
            
            if command == '/s': # Scan
                # ... (unchanged)
                with peer_lock: peer_list = sorted(list(available_peers))
                if not peer_list: await aioconsole.aprint(format_message("System", "No other peers found yet."))
                else:
                    await aioconsole.aprint(Fore.YELLOW + "--- Available Peers ---")
                    for i, ip in enumerate(peer_list): await aioconsole.aprint(f"  [{i}] {ip}")
                    await aioconsole.aprint(format_message("System", "Use '/connect <number>' to connect."))

            elif command == '/connect': # Connect
                # ... (unchanged)
                if len(parts) < 2: await aioconsole.aprint(format_message("System", "Usage: /connect <number>", color=Fore.RED)); continue
                try:
                    choice = int(parts[1])
                    with peer_lock: peer_list = sorted(list(available_peers))
                    if 0 <= choice < len(peer_list): asyncio.create_task(connect_to_peer(peer_list[choice], routing_manager))
                    else: await aioconsole.aprint(format_message("System", "That number is not in the list.", color=Fore.RED))
                except (ValueError, IndexError): await aioconsole.aprint(format_message("System", "Invalid selection.", color=Fore.RED))

            elif command == '/map': # New command to view topology
                await aioconsole.aprint(Fore.YELLOW + "--- Network Map ---")
                for node, neighbors in routing_manager.topology.adjacency():
                    neighbor_list = ", ".join(neighbors)
                    await aioconsole.aprint(f"  {node} -> [{neighbor_list}]")
            
            elif command == '/msg': # New Private Message command
                if len(parts) < 3:
                    await aioconsole.aprint(format_message("System", "Usage: /msg <destination_ip> <message>", color=Fore.RED))
                    continue
                dest_ip, payload = parts[1], " ".join(parts[2:])
                next_hop = routing_manager.get_next_hop(dest_ip)
                if not next_hop:
                    await aioconsole.aprint(format_message("System", f"No path to {dest_ip} found.", color=Fore.RED))
                    continue
                
                message_data = {
                    "type": "chat", "id": str(uuid.uuid4()), "origin_ip": LOCAL_IP,
                    "destination_ip": dest_ip, "hops": 0, "payload": payload
                }
                await aioconsole.aprint(format_message(LOCAL_IP, payload, is_self=True, is_private=True))
                
                # Send ONLY to the next hop
                for writer in list(peers):
                    if writer.get_extra_info('peername')[0] == next_hop:
                        writer.write((json.dumps(message_data) + "\n").encode())
                        await writer.drain(); break

            elif command == '/q': break # Quit
            else: await aioconsole.aprint(format_message("System", "Unknown command. Use /h for help."))

        else: # Broadcast (group chat) message
            message_data = {
                "type": "chat", "id": str(uuid.uuid4()), "origin_ip": LOCAL_IP,
                "destination_ip": "all", "hops": 0, "payload": user_input
            }
            await aioconsole.aprint(format_message(LOCAL_IP, user_input, is_self=True))
            for writer in list(peers):
                writer.write((json.dumps(message_data) + "\n").encode())
                await writer.drain()

async def main():
    print("--- P2P Dijkstra Mesh Chat ---"); print(f"[Info] Your IP: {LOCAL_IP}")
    routing_manager = RoutingManager(LOCAL_IP, peers)
    server = await asyncio.start_server(
        lambda r, w: handle_peer(r, w, routing_manager), LOCAL_IP, PORT)
    loop = asyncio.get_running_loop()
    await asyncio.gather(
        server.serve_forever(),
        loop.run_in_executor(None, udp_broadcast_task),
        loop.run_in_executor(None, udp_listen_task),
        chat_interface(routing_manager),
        routing_manager.broadcast_lsa())

if __name__ == "__main__":
    try: asyncio.run(main())
    except (KeyboardInterrupt, asyncio.CancelledError): pass
    finally: print("\nExiting...")
