import asyncio
import socket
import threading
import time
import colorama
from colorama import Fore, Style
import aioconsole

# --- Initialize Libraries & Constants ---
colorama.init(autoreset=True)
PORT = 8888
BROADCAST_PORT = 9999

# --- Global State ---
peers = set()  # A set of connected asyncio.StreamWriter objects
available_peers = set()  # A set of discovered IP addresses
peer_lock = threading.Lock() # A lock for safely modifying available_peers

def get_local_ip():
    """Gets the machine's local IP address."""
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
            s.connect(("8.8.8.8", 80))
            return s.getsockname()[0]
    except Exception:
        return "127.0.0.1"

LOCAL_IP = get_local_ip()

# --- Message Formatting ---
def format_message(sender_ip, message, is_self=False):
    """Formats messages with appropriate colors."""
    color = Fore.CYAN  # Default color for peers
    if is_self:
        sender = "Me"
        color = Fore.GREEN
    elif sender_ip == "System":
        sender = "System"
        color = Fore.YELLOW
    else:
        sender = sender_ip
    
    return f"{color}{sender}: {Style.RESET_ALL}{message}"

# --- Networking Core: Connection & Server ---
async def connect_to_peer(ip: str):
    """Establishes a TCP connection to a peer."""
    connected_ips = [w.get_extra_info('peername')[0] for w in peers if w.get_extra_info('peername')]
    if ip == LOCAL_IP or ip in connected_ips:
        return

    try:
        await aioconsole.aprint(format_message("System", f"Attempting to connect to {ip}..."))
        reader, writer = await asyncio.wait_for(asyncio.open_connection(ip, PORT), timeout=5)
        peers.add(writer)
        peer_ip = writer.get_extra_info('peername')[0]
        await aioconsole.aprint(format_message("System", f"✅ Successfully connected to {peer_ip}"))
    except Exception as e:
        await aioconsole.aprint(format_message("System", f"❌ Failed to connect to {ip}: {e}", color=Fore.RED))

async def handle_peer(reader: asyncio.StreamReader, writer: asyncio.StreamWriter):
    """Handles incoming messages from a connected peer."""
    peers.add(writer)
    peer_ip = writer.get_extra_info('peername')[0]
    await aioconsole.aprint(format_message("System", f"🔗 New peer connected: {peer_ip}"))
    
    try:
        while True:
            data = await reader.readline()
            if not data:
                break
            message = data.decode().strip()
            await aioconsole.aprint(format_message(peer_ip, message))
    except (ConnectionResetError, asyncio.IncompleteReadError):
        pass  # The finally block will handle cleanup
    finally:
        await aioconsole.aprint(format_message("System", f"🏃 Peer {peer_ip} disconnected."))
        if writer in peers:
            peers.remove(writer)
        writer.close()
        await writer.wait_closed()

# --- UDP Discovery Threads ---
def udp_broadcast_task():
    """Broadcasts our IP on the network in a separate thread."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        while True:
            try:
                sock.sendto(LOCAL_IP.encode(), ("255.255.255.255", BROADCAST_PORT))
            except Exception:
                pass # Avoid crashing on network errors
            time.sleep(5)

def udp_listen_task():
    """Listens for peer broadcasts in a separate thread."""
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('', BROADCAST_PORT))
        while True:
            ip = sock.recvfrom(1024)[0].decode()
            if ip != LOCAL_IP:
                with peer_lock:
                    available_peers.add(ip)

# --- Main User Interface Loop ---
async def chat_interface():
    """Handles user input for sending messages and commands."""
    await aioconsole.aprint(format_message("System", "Welcome! Type '/s' to scan for peers, '/h' for help."))
    while True:
        user_input = await aioconsole.ainput("> ")

        if not user_input:
            continue

        if user_input.startswith('/'):
            command = user_input.lower()
            if command == '/s':
                with peer_lock:
                    peer_list = sorted(list(available_peers))
                
                if not peer_list:
                    await aioconsole.aprint(format_message("System", "No other peers found yet. Wait a moment and try again."))
                    continue
                
                await aioconsole.aprint(Fore.YELLOW + "--- Available Peers ---")
                for i, ip in enumerate(peer_list):
                    await aioconsole.aprint(f"  [{i}] {ip}")
                
                try:
                    choice_str = await aioconsole.ainput("Enter number to connect (or 'c' to cancel): ")
                    if choice_str.lower() == 'c':
                        continue
                    ip_to_connect = peer_list[int(choice_str)]
                    asyncio.create_task(connect_to_peer(ip_to_connect))
                except (ValueError, IndexError):
                    await aioconsole.aprint(format_message("System", "Invalid selection.", color=Fore.RED))

            elif command == '/h':
                await aioconsole.aprint(format_message("System", "Commands: /s (scan & connect), /q (quit), /h (help)"))
            
            elif command == '/q':
                break
            else:
                await aioconsole.aprint(format_message("System", f"Unknown command: {command}", color=Fore.RED))
        
        else: # It's a chat message
            await aioconsole.aprint(format_message(LOCAL_IP, user_input, is_self=True))
            for writer in list(peers):
                if not writer.is_closing():
                    try:
                        writer.write(f"{user_input}\n".encode())
                        await writer.drain()
                    except (ConnectionResetError, BrokenPipeError):
                        peers.discard(writer)
    
    # Graceful shutdown
    for task in asyncio.all_tasks():
        if task is not asyncio.current_task():
            task.cancel()

async def main():
    """Initializes and runs all concurrent tasks."""
    print("--- P2P Chat ---")
    print(f"[Info] Your IP: {LOCAL_IP}")

    server = await asyncio.start_server(handle_peer, LOCAL_IP, PORT)
    loop = asyncio.get_running_loop()

    await asyncio.gather(
        server.serve_forever(),
        loop.run_in_executor(None, udp_broadcast_task),
        loop.run_in_executor(None, udp_listen_task),
        chat_interface()
    )

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, asyncio.CancelledError):
        print("\nExiting...")
